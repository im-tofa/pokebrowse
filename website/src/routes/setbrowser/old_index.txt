/**
 * PokÃ©mon Showdown uses a global dex for the teambuilder,
 * that is essentially a js/ts file with all content in it 
 * as a js object, since the teambuilder rarely changes & 
 * is limited. My application intends to share sets between
 * users, and the sets can be arbitrary, so a database is 
 * needed to store this. Communication with a database thus 
 * needs to occur through a server, to validate any searches
 * before requesting from the database.
 * 
 */


import { Component, FunctionalComponent, h } from 'preact';
import style from './style.css';
import { useState, useCallback, useReducer } from 'preact/hooks';
import Filter from './../../components/filter';
import parseInput from './tokenizer';

class SetBrowser extends Component {
  constructor(props) {
    super(props);
    this.state = {};

    /**
     * This is required because 'onClick={this.func}' passes 
     * a copy of the method reference to onClick, so when 
     * onClick executes using onClick() there is no preceding 
     * 'this.', which causes an unbound this in the method.
     * Binding overrides this whacky behavior since it forces 
     * 'this' to be bound to the particular 'this' of the object
     * containing the method, by wrapping the original method in another 
     * method that provides 'this' to the original method.
     */
    this.removeFilter = this.removeFilter.bind(this);
    this.generateFilters = this.generateFilters.bind(this);
    this.changeQuery = this.changeQuery.bind(this);
    this.supress = this.supress.bind(this);
  }

  removeFilter(key) {
    delete this.state[key]; // delete 
    this.setState({...this.state}); // setState to trigger re-render
  } 

  generateFilters() {
    return Object.entries(this.state).map(e => <Filter filterType={e[0]} filterValue={e[1].val} inputType={e[1].inputType} remove={(event) => {event.preventDefault(); this.removeFilter(e[0])}}></Filter>);
  };

  changeQuery(e: InputEvent) {
    let input: string = e.target.value;
    //console.log(key);
    //console.log(value);
    if(e.key === 'Enter') {
      /* 
        TODO: parse input into tokens, use these to validate
        against expected grammar using recursive descent.
        Produce error/message if incorrect command.
      */
      const res = parseInput(input);
      if(res){
        e.preventDefault();
        console.log(this);
        const append = {};
        append[res.key.toLowerCase()] = {val: res.val, inputType: res.inputType};
        this.setState(append);
        //console.log(this.state);
        e.target.value = "";
      }
      
    }
  };

  supress(e: InputEvent){
    if(e.key === 'Enter') {
      e.preventDefault();
    }
  };

  render() {
    return (
      <div class={style.setbrowser}>
          <form class={style.filters}>
            <div class={style.cli}>
              <h3>Browse: </h3>
              <input type="text" class={style.cmd} onKeyUp={this.changeQuery} onKeyDown={this.supress}></input>
            </div>
            {Object.keys(this.state).length > 0 && <div class={style.chosen}>
              <h5>Filters: </h5>
              {this.generateFilters()}
            </div>}
          </form>
          <div></div>
          <div class={style.results}>
            {this.state.results && Object.keys(this.state.results).length > 0 && <h2>Results</h2>}

          </div>
      </div>
  );
  }
}

export default SetBrowser;
